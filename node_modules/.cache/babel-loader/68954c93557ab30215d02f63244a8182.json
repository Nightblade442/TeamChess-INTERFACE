{"ast":null,"code":"import { SET_IMPLICIT_GRANT_CREDENTIALS, SET_BOARD, SET_SELECTED } from \"../constants/action-types\";\nimport * as moment from 'moment';\n\nfunction getMoves(board, pieceLocation, players) {\n  let piece = board[pieceLocation.x][pieceLocation.y];\n  let possibleMoves = [];\n  console.log(piece.owner);\n  let moveTemplate = {\n    pawn_w: [{\n      type: \"SINGLE\",\n      direction: {\n        x: 1,\n        y: 1\n      },\n      takeable: true,\n      jumpable: false\n    }, {\n      type: \"SINGLE\",\n      direction: {\n        x: 1,\n        y: 1\n      },\n      takeable: true,\n      jumpable: false\n    }, {\n      type: \"CONTINUOUS\",\n      direction: {\n        x: -1,\n        y: 1\n      },\n      takeable: true,\n      jumpable: false\n    }]\n  };\n\n  if (moveTemplate[piece.type] !== undefined) {\n    console.log(\"this piece's moves are defined\");\n    let pieceTemplate = moveTemplate[piece.type];\n    pieceTemplate.forEach(moveSet => {\n      console.log(moveSet);\n\n      if (moveSet.type === \"SINGLE\") {\n        try {\n          let moveLocation = {\n            x: pieceLocation.x + moveSet.direction.x,\n            y: pieceLocation.y + moveSet.direction.y\n          };\n          let moveSquare = board[moveLocation.x][moveLocation.y];\n\n          if (moveSquare.type === null) {\n            possibleMoves.push(moveLocation);\n          } else {//need to check if the piece on the target square is takeable\n          }\n        } catch (error) {\n          console.log(error);\n          console.log(\"move outside board boundaries\");\n        }\n      } else {\n        console.log(\"here at least\");\n        let attempt = 1;\n\n        while (true) {\n          let moveLocation = {\n            x: pieceLocation.x + moveSet.direction.x * attempt,\n            y: pieceLocation.y + moveSet.direction.y * attempt\n          };\n\n          try {\n            let moveSquare = board[moveLocation.x][moveLocation.y];\n\n            if (moveSquare.type === null) {\n              possibleMoves.push(moveLocation);\n            } else {\n              //need to check if the piece on the target square is takeable\n              console.log(moveSquare.type);\n              let piece1Colour = piece.type.split(\"_\")[1];\n              let piece2Colour = moveSquare.type.split(\"_\")[1];\n\n              if (piece1Colour !== piece2Colour) {\n                possibleMoves.push(moveLocation);\n\n                if (!moveSet.jumpable) {\n                  console.log(\"end of row\");\n                  break;\n                }\n              }\n            }\n          } catch {\n            console.log(\"Square Outside Boundaries of the board\");\n            break;\n          }\n\n          attempt++;\n        }\n      }\n    });\n  }\n\n  return possibleMoves;\n}\n\nfunction appReducer(state, action) {\n  //tell redux how to deal with data in each action case. one for each action.\n  let newstate = null;\n  console.log(action.type);\n\n  if (action.type === SET_IMPLICIT_GRANT_CREDENTIALS) {\n    //after getting access token \n    newstate = { ...state,\n      loggedIn: true,\n      loginErrorMessage: null,\n      access_token: action.payload.access_token,\n      implicitGrantExpiry: moment().add(86398, 'seconds')\n    };\n  } else if (action.type === SET_BOARD) {\n    newstate = { ...state,\n      highlightedSquares: [],\n      selectedSquare: {\n        x: null,\n        y: null\n      },\n      board: action.payload.board\n    };\n  } else if (action.type === SET_SELECTED) {\n    let highlightedSquares = [];\n\n    if (state.board[action.payload.selected.x][action.payload.selected.y].type !== null) {\n      console.log(\"this is a piece\");\n      highlightedSquares = getMoves(state.board, action.payload.selected);\n    }\n\n    newstate = { ...state,\n      selectedSquare: action.payload.selected,\n      highlightedSquares: highlightedSquares\n    };\n  } else {\n    newstate = { ...state\n    };\n  }\n\n  return newstate;\n}\n\nexport default appReducer;","map":{"version":3,"sources":["C:/Users/Jack/OneDrive/Documents/Long Chess/React Version/src/Redux/reducers/reducer.js"],"names":["SET_IMPLICIT_GRANT_CREDENTIALS","SET_BOARD","SET_SELECTED","moment","getMoves","board","pieceLocation","players","piece","x","y","possibleMoves","console","log","owner","moveTemplate","pawn_w","type","direction","takeable","jumpable","undefined","pieceTemplate","forEach","moveSet","moveLocation","moveSquare","push","error","attempt","piece1Colour","split","piece2Colour","appReducer","state","action","newstate","loggedIn","loginErrorMessage","access_token","payload","implicitGrantExpiry","add","highlightedSquares","selectedSquare","selected"],"mappings":"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","sourcesContent":["import {\r\n    SET_IMPLICIT_GRANT_CREDENTIALS,\r\n    SET_BOARD,\r\n    SET_SELECTED\r\n} from \"../constants/action-types\";\r\nimport * as moment from 'moment';\r\n\r\nfunction getMoves(board, pieceLocation, players) {\r\n    let piece = board[pieceLocation.x][pieceLocation.y];\r\n    let possibleMoves = [];\r\n    console.log(piece.owner);\r\n    let moveTemplate = {\r\n        pawn_w: [\r\n            {\r\n                type: \"SINGLE\",\r\n                direction: {\r\n                    x: 1,\r\n                    y: 1\r\n                },\r\n                takeable: true,\r\n                jumpable: false\r\n\r\n            },\r\n            {\r\n                type: \"SINGLE\",\r\n                direction: {\r\n                    x: 1,\r\n                    y: 1\r\n                },\r\n                takeable: true,\r\n                jumpable: false\r\n            },\r\n            {\r\n                type: \"CONTINUOUS\",\r\n                direction: {\r\n                    x: -1,\r\n                    y: 1\r\n                },\r\n                takeable: true,\r\n                jumpable: false,\r\n            }\r\n        ]\r\n    }\r\n\r\n    if (moveTemplate[piece.type] !== undefined) {\r\n        console.log(\"this piece's moves are defined\");\r\n        let pieceTemplate = moveTemplate[piece.type];\r\n        pieceTemplate.forEach(moveSet => {\r\n            console.log(moveSet);\r\n            if (moveSet.type === \"SINGLE\") {\r\n                try {\r\n                    let moveLocation = {\r\n                        x: pieceLocation.x + moveSet.direction.x,\r\n                        y: pieceLocation.y + moveSet.direction.y\r\n                    }\r\n                    let moveSquare = board[moveLocation.x][moveLocation.y];\r\n                    if (moveSquare.type === null) {\r\n                        possibleMoves.push(moveLocation);\r\n                    }\r\n                    else {\r\n                        //need to check if the piece on the target square is takeable\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.log(error);\r\n                    console.log(\"move outside board boundaries\")\r\n                }\r\n            }\r\n            else {\r\n                console.log(\"here at least\");\r\n                let attempt = 1;\r\n                while (true) {\r\n                    let moveLocation = {\r\n                        x: pieceLocation.x + (moveSet.direction.x * attempt),\r\n                        y: pieceLocation.y + (moveSet.direction.y * attempt)\r\n                    }\r\n                    try {\r\n                        let moveSquare = board[moveLocation.x][moveLocation.y];\r\n                        if (moveSquare.type === null) {\r\n                            possibleMoves.push(moveLocation);\r\n                        }\r\n                        else {\r\n                            //need to check if the piece on the target square is takeable\r\n                            console.log(moveSquare.type);\r\n                            let piece1Colour = piece.type.split(\"_\")[1];\r\n                            let piece2Colour = moveSquare.type.split(\"_\")[1];\r\n                            if(piece1Colour !== piece2Colour){\r\n                                possibleMoves.push(moveLocation);\r\n                                if(!moveSet.jumpable){\r\n                                    console.log(\"end of row\");\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    catch {\r\n                        console.log(\"Square Outside Boundaries of the board\");\r\n                        break;\r\n                    }\r\n                    attempt++;\r\n                }\r\n            }\r\n        })\r\n    }\r\n    return possibleMoves;\r\n}\r\n\r\nfunction appReducer(state, action) {\r\n    //tell redux how to deal with data in each action case. one for each action.\r\n    let newstate = null;\r\n    console.log(action.type);\r\n    if (action.type === SET_IMPLICIT_GRANT_CREDENTIALS) { //after getting access token \r\n        newstate = {\r\n            ...state,\r\n            loggedIn: true,\r\n            loginErrorMessage: null,\r\n            access_token: action.payload.access_token,\r\n            implicitGrantExpiry: moment().add(86398, 'seconds'),\r\n        };\r\n    }\r\n    else if (action.type === SET_BOARD) {\r\n        newstate = {\r\n            ...state,\r\n            highlightedSquares: [],\r\n            selectedSquare: {\r\n                x: null,\r\n                y: null\r\n            },\r\n            board: action.payload.board\r\n        }\r\n    }\r\n    else if (action.type === SET_SELECTED) {\r\n        let highlightedSquares = [];\r\n        if (state.board[action.payload.selected.x][action.payload.selected.y].type !== null) {\r\n            console.log(\"this is a piece\");\r\n            highlightedSquares = getMoves(state.board, action.payload.selected);\r\n        }\r\n        newstate = {\r\n            ...state,\r\n            selectedSquare: action.payload.selected,\r\n            highlightedSquares: highlightedSquares\r\n        }\r\n    }\r\n    else {\r\n        newstate = { ...state };\r\n    }\r\n\r\n    return newstate;\r\n}\r\n\r\nexport default appReducer;"]},"metadata":{},"sourceType":"module"}